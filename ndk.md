# 开发自己的 NDK 程序

入门的最好办法就是学习 Android 自带的例子， 这里就通过学习 Android 的 NDK 自带的 demo 程序：hello-jni来达到这个目的。

## 开发环境的搭建

- android 的 NDK 开发需要在 linux 下进行： 因为需要把 C/C++ 编写的代码生成能在 arm 上运行的`.so`文件，这就需要用到交叉编译环境，而交叉编译需要在 linux 系统下才能完成。

- 安装 android-ndk 开发包，这个开发包可以在 google android 官网下载： 通过这个开发包的工具才能将android jni 的 C/C++ 的代码编译成库

- android 应用程序开发环境： 包括 eclipse、java、android sdk、adt 等。

如何下载和安装 android-ndk 我这里就不啰嗦了，安装完之后，需要将 android-ndk 的路劲加到环境变量 PATH 中：

```
　　　　sudo gedit /etc/environment
```

在 environment 的 PATH 环境变量中添加你的 android-ndk 的安装路劲，然后再让这个更改的环境变量立即生效：

```
　　　　 source  /etc/environment
```

经过了上述步骤，在命令行下敲：

```
　　　　ndk-bulid
```

弹出如下的错误，而不是说 ndk-build not found，就说明 ndk 环境已经安装成功了。

```
　Android NDK: Could not find application project directory !    
　Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.    
　/home/braincol/workspace/android/android-ndk-r5/build/core/build-local.mk:85: *** Android NDK: Aborting    .  Stop.
```

## 代码的编写

### 编写 Java 代码

建立一个 Android 应用工程 HelloJni，创建 HelloJni.java 文件：

HelloJni.java :

```
import android.app.Activity;
import android.widget.TextView;
import android.os.Bundle;

public class HelloJni extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        TextView  tv = new TextView(this);
        tv.setText( stringFromJNI() );
        setContentView(tv);
    }


    /* A native method that is implemented by the 'hello-jni' native library, which is packaged with this application. */
    public native String  stringFromJNI();

    public native String  unimplementedStringFromJNI();



    /* this is used to load the 'hello-jni' library on application startup. The library has already been unpacked into

      /data/data/com.example.HelloJni/lib/libhello-jni.so at installation time by the package manager. */
    static {
        System.loadLibrary("hello-jni");
    }
}
```

代码解释：

```
static{ 
System.loadLibrary("hello-jni"); 
}
```

表明程序开始运行的时候会加载 hello-jni, static 区声明的代码会先于 onCreate 方法执行。如果你的程序中有多个类，而且如果 HelloJni 这个类不是你应用程序的入口，那么 hello-jni（完整的名字是 libhello-jni.so）这个库会在第一次使用 HelloJni 这个类的时候加载。

```
public native String stringFromJNI(); 
public native String unimplementedStringFromJNI();
```

可以看到这两个方法的声明中有 native 关键字， 这个关键字表示这两个方法是本地方法，也就是说这两个方法是通过本地代码（C/C++）实现的，在java代码中仅仅是声明。

用 eclipse 编译该工程，生成相应的`.class`文件，这步必须在下一步之前完成，因为生成`.h`文件需要用到相应的`.class`文件。

### 编写相应的 C/C++ 代码

刚开始学的时候，有个问题会让人很困惑，相应的 C/C++ 代码如何编写，函数名如何定义？ 这里讲一个方法，利用 javah 这个工具生成相应的`.h`文件，然后根据这个`.h`文件编写相应的 C/C++ 代码。

1.生成相应`.h`文件：

就拿我这的环境来说，首先在终端下进入刚刚建立的 HelloJni 工程的目录：

```
braincol@ubuntu:~$ cd workspace/android/NDK/hello-jni/
```

ls 查看工程文件

```
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls 

AndroidManifest.xml  assets  bin  default.properties  gen  res  src 
```

可以看到目前仅仅有几个标准的 android 应用程序的文件（夹）。

首先我们在工程目录下建立一个 jni 文件夹：

```
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ mkdir jni
 
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls
 
AndroidManifest.xml  assets  bin  default.properties  gen  jni  res  src 
```

下面就可以生成相应的`.h`文件了：

```
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ javah -classpath bin -d jni com.example.hellojni.HelloJni 
```

-classpath bin：表示类的路劲

-d jni: 表示生成的头文件存放的目录

com.example.hellojni.HelloJni 则是完整类名

这一步的成功要建立在已经在 bin/com/example/hellojni/  目录下生成了 HelloJni.class 的基础之上。现在可以看到 jni 目录下多了个`.h`文件：

```
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ cd jni/ 

braincol@ubuntu:~/workspace/android/NDK/hello-jni/jni$ ls 

com_example_hellojni_HelloJni.h
```

我们来看看 com_example_hellojni_HelloJni.h 的内容：

com_example_hellojni_HelloJni.h :

```
/* DO NOT EDIT THIS FILE - it is machine generated */

#include <jni.h>

/* Header for class com_example_hellojni_HelloJni */

#ifndef _Included_com_example_hellojni_HelloJni

#define _Included_com_example_hellojni_HelloJni

#ifdef __cplusplus

extern "C" {

#endif

/*

 * Class:     com_example_hellojni_HelloJni

 * Method:    stringFromJNI

 * Signature: ()Ljava/lang/String;

 */

JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI

  (JNIEnv *, jobject);


/*

 * Class:     com_example_hellojni_HelloJni

 * Method:    unimplementedStringFromJNI

 * Signature: ()Ljava/lang/String;

 */

JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI

  (JNIEnv *, jobject);


#ifdef __cplusplus

}

#endif

#endif
```

上面代码中的 JNIEXPORT 和 JNICALL 是 jni 的宏，在 android 的 jni 中不需要，当然写上去也不会有错。从上面的源码中可以看出这个函数名那是相当的长啊。不过还是很有规律的，完全按照：java_pacakege_class_mathod 形式来命名。

也就是说：

Hello.java 中 stringFromJNI() 方法对应于 C/C++中的 Java_com_example_hellojni_HelloJni_stringFromJNI() 方法

HelloJni.java 中的 unimplementedStringFromJNI() 方法对应于 C/C++中的 Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI() 方法 

注意下其中的注释：

Signature: ()Ljava/lang/String; 

()Ljava/lang/String;()表示函数的参数为空（这里为空是指除了JNIEnv *, jobject 这两个参数之外没有其他参数，JNIEnv*, jobject 是所有 jni 函数必有的两个参数，分别表示 jni 环境和对应的 java 类（或对象）本身），Ljava/lang/String; 表示函数的返回值是 java 的 String 对象。


### 编写相应的`.c`文件

hello-jni.c :

```
#include <string.h>
#include <jni.h>


/* This is a trivial JNI example where we use a native method

 * to return a new VM String. See the corresponding Java source

 * file located at:

 *   apps/samples/hello-jni/project/src/com/example/HelloJni/HelloJni.java

 */

jstring Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )
{
    return (*env)->NewStringUTF(env, "Hello from JNI !");
}
```

这里只是实现了 Java_com_example_hellojni_HelloJni_stringFromJNI 方法，而 Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI 方法并没有实现，因为在HelloJni.java 中只调用了 stringFromJNI()方法，所以 unimplementedStringFromJNI()方法没有实现也没关系，不过建议最好还是把所有 java 中定义的本地方法都实现了，写个空函数也行。有总比没有好。

Java_com_example_hellojni_HelloJni_stringFromJNI() 函数只是简单的返回了一个内容为 "Hello from JNI !" 的 jstring 对象（对应于 Java 中的 String 对象）。`hello-jni.c`文件已经编写好了，现在可以把`com_example_hellojni_HelloJni.h`文件给删了，当然留着也行，只是习惯是把不需要的文件给清理干净了。

## 编译 hello-jni.c 生成相应的库

### 编写 Android.mk 文件

在 jni 目录下（即`hello-jni.c`同级目录下）新建一个`Android.mk`文件，`Android.mk`文件是 Android 的 makefile 文件，内容如下：

```
# Copyright (C) 2009 The Android Open Source Project

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#      http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#

LOCAL_PATH := $(call my-dir)



include $(CLEAR_VARS)



LOCAL_MODULE    := hello-jni

LOCAL_SRC_FILES := hello-jni.c



include $(BUILD_SHARED_LIBRARY)
```

这个 Androd.mk 文件很短，下面我们来逐行解释下：

```
LOCAL_PATH := $(call my-dir)
```

一个 Android.mk 文件首先必须定义好 LOCAL_PATH 变量。它用于在开发树中查找源文件。在这个例子中，宏函数`’my-dir’`, 由编译系统提供，用于返回当前路径（即包含 Android.mk file 文件的目录）。

```
include $( CLEAR_VARS)
```

CLEAR_VARS 由编译系统提供，指定让 GNU MAKEFILE 为你清除许多 LOCAL_XXX 变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等...), 除 LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个 GNU MAKE 执行环境中，所有的变量都是全局的。

```
LOCAL_MODULE := hello-jni
```

编译的目标对象，LOCAL_MODULE 变量必须定义，以标识你在`Android.mk`文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。

注意：编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为`hello-jni`的共享库模块，将会生成`libhello-jni.so`文件。

重要注意事项：如果你把库命名为`libhello-jni`，编译系统将不会添加任何的 lib 前缀，也会生成 `libhello-jni.so`，这是为了支持来源于 Android 平台的源代码的`Android.mk`文件，如果你确实需要这么做的话。

```
LOCAL_SRC_FILES := hello-jni.c
```

LOCAL_SRC_FILES 变量必须包含将要编译打包进模块中的 C 或 C++ 源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。

注意，默认的 C++ 源码文件的扩展名是`.cpp`指定一个不同的扩展名也是可能的，只要定义LOCAL_DEFAULT_CPP_EXTENSION 变量，不要忘记开始的小圆点（也就是`.cxx`,而不是`cxx`）

```
include $(BUILD_SHARED_LIBRARY)
```

BUILD_SHARED_LIBRARY 表示编译生成共享库，是编译系统提供的变量，指向一个 GNU Makefile 脚本，负责收集自从上次调用`include $(CLEAR_VARS)`以来，定义在 LOCAL_XXX 变量中的所有信息，并且决定编译什么，如何正确地去做。还有 BUILD_STATIC_LIBRARY 变量表示生成静态库：`lib$(LOCAL_MODULE).a`， BUILD_EXECUTABLE 表示生成可执行文件。

### 生成`.so`共享库文件

Andro 文件已经编写好了，现在可以用 android NDK 开发包中的 ndk-build 脚本生成对应的`.so`共享库了，方法如下：

```
braincol@ubuntu:~/workspace/android/NDK/hello-jni/jni$ cd .. 
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls 
AndroidManifest.xml  assets  bin  default.properties  gen  jni  libs  obj  res  src 
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ndk-build 
Gdbserver      : [arm-linux-androideabi-4.4.3] libs/armeabi/gdbserver 
Gdbsetup       : libs/armeabi/gdb.setup 
Install        : libhello-jni.so => libs/armeabi/libhello-jni.so 
```

可以看到已经正确的生成了`libhello-jni.so`共享库了， 我们去`libs/armeabi/`目录下看看：

```
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ cd libs/ 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs$ ls 
armeabi 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs$ cd armeabi/ 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs/armeabi$ ls 
gdbserver  gdb.setup  libhello-jni.so
```

## 在 eclipse 重新编译 HelloJni 工程，生成 apk

eclipse 中刷新下 HelloJni 工程，重新编译生成 apk，libhello-jni.so 共享库会一起打包在 apk 文件内。在模拟器中看看运行结果。